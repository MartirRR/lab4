# üå≥ LAB4: √Årboles Binarios de B√∫squeda en el Sistema de M√∫sica en Streaming

## Objetivos Generales
1. Comprender e implementar un √Årbol Binario de B√∫squeda (ABB) gen√©rico en Python.  
2. Aplicar principios de responsabilidad √∫nica separando la l√≥gica gen√©rica de estructuras de datos de la l√≥gica de dominio.  
3. Integrar el ABB en el sistema de streaming para acelerar b√∫squedas y mantener las canciones ordenadas.  
4. Practicar la definici√≥n de clases y subclases, uso de m√©todos m√°gicos y modularidad.

## Archivos Proporcionados
- arbol_binario.py
- arbol_binario_busqueda.py  
- T√∫ c√≥digo del LAB3 con Catalogo, Usuario, etc.

## Actividades

### 0. L√≥gica Gen√©rica del ABB
- Revisa las clases proporcionadas de AB y ABB y completa las funciones que faltan.  
- Todas las funciones de b√∫squeda, agregar o eliminar deben trabajar a nivel de objeto, en nuestro caso `valor = Cancion`.
- Prueba tus implementaciones

### 1. Clase Cancion con M√©todos "M√°gicos"
- Asegurar que la clase Cancion implemente `__lt__` y `__eq__` basados en el t√≠tulo y artista (orden alfab√©tico). Podemos implementar `__gt__`(greater than)
  - Primero calculamos si un t√≠tulo es mayor que otro (self.__get_titulo() < otra_cancion.get_titulo())
  - En caso de que el t√≠tulo sea igual, calculamos la diferencia entre los artistas
- Garantizar que las comparaciones entre objetos Cancion funcionen de manera consistente.

### 2. Crea una subclase de ABB para un ABB de Canciones
- Crea ArbolCancion, subclase de ArbolBinarioBusqueda, con m√©todos de nuestro programa, como por ejemplo funciones para buscar por t√≠tulo y artista.
- Ejemplo de c√≥digo para buscar por t√≠tulo y artista usando ArbolCancion
```python
def busca_cancion(self, titulo_cancion, artista):
    raiz = self.get_raiz()
    cancion = Cancion(titulo_cancion,artista,...) # completar creando una cancion temporal para ser buscada (el resto de valores no hacen falta)
    return raiz.busca_valor(cancion)
```
### 3. Integraci√≥n en el Cat√°logo
- Modificar la clase Cat√°logo para usar ArbolCancion, como un nuevo atributo donde las canciones estar√°n en un ABB.  
- Extiende los m√©todos en Cat√°logo de agregar y eliminar para que tambi√©n a√±adan y eliminen del ABB.
- Implementa una nueva funci√≥n de buscar por t√≠tulo y artista que use el ABB dentro de cat√°logo.

### 4. Haz pruebas de busquedas y calcula el tiempo

- En `main.py` implementa una funci√≥n que:
  1. Selecciona 5 canciones al azar del cat√°logo (puedes hacer un random select 0 a 200/1000 y seleccionarlas por ID).
  2. Para cada cancion, ejecuta 5 b√∫squedas en la **lista enlazada** y mide el tiempo medio de b√∫squeda.
  3. Para cada cancion, ejecuta 5 b√∫squedas en el **ABB** y mide el tiempo medio de b√∫squeda.
  4. Calcula y muestra (en `experiments.md`) los tiempos medios de b√∫squeda para cada canci√≥n.

**TIP**: Si no ves mucha diferencia en los tiempos, puedes usar el archivo 1000_canciones.csv 
**TIP2**: (OPCIONAL) Para generar un poco m√°s de aleatoriedad, antes de introducir las canciones en la lista enlazada podr√≠amos hacer un shuffle, para mezclarlas.
```python
import random
# leo mis canciones del archivo y las meto en una lista de python normal (canciones = [])
random.shuffle(canciones)
for c in canciones:
    catalogo.agregar_cancion(c) # aqu√≠ debe agregar a lista enlazada y al arbol binario de b√∫squeda 
```

Aqu√≠ tienes un ejemplo de c√≥digo para medir tiempos de ejecuci√≥n
```python
import time

# Ejemplo de funci√≥n a cronometrar
def mi_tarea():
    total = 0
    for i in range(10_000_000):
        total += i
    return total

# Medir tiempo de ejecuci√≥n
start = time.perf_counter()
resultado = mi_tarea()
end = time.perf_counter()

elapsed_ms = (end - start) * 1000  # milisegundos
print(f"Tiempo de ejecuci√≥n: {elapsed_ms:.4f}¬†ms")
```

## Criterios de Entrega
- C√≥digo bien estructurado y documentado.  
- Pruebas unitarias que cubran inserci√≥n, b√∫squeda, eliminaci√≥n y recorrido.
- Demostraci√≥n de la b√∫squeda eficiente y del cat√°logo ordenado en consola.  